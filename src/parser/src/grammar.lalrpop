use std::str::FromStr;
use base::ast;
use base::types::Location;

grammar;

Comma: () = {
    "," => (),
    // <!> => ()
    // <!> => errors.push(<>.error)
};

Semicolon: () = {
    ";" => (),
    // <!> => ()
    // <!> => errors.push(<>.error)
};

Empty: () = {
    "" => (),
    // <!> => ()
    // <!> => errors.push(<>.error)
};

List<Rule, Separator>: Vec<Rule> =
  <list: (<Rule> <Separator>)*> <last: Rule?> => {
    let mut rules = Vec::new();
    for (rule, sep) in list {
      rules.push(rule);
    }
    match last {
      Some(rule) => rules.push(rule),
      _ => (),
    }
    rules
  };

ListNoSep<Rule>: Vec<Rule> =
  <list: (<Rule>)*> => {
    let mut rules = Vec::new();
    for rule in list {
      rules.push(rule);
    }
    rules
  };

// -------------------  TYPES  -------------------
pub Type: ast::Type = {
    "int"     => ast::Type::Int,  // Int
    "string"  => ast::Type::Str,  // Str
    "boolean" => ast::Type::Bool, // Boolean
    "void"    => ast::Type::Void, // Void
};

// ------------------- PROGRAM -------------------

pub Program: ast::Program = {
  <defs: ListNoSep<TopDef>> => ast::Program { <> }, // Program
};

pub TopDef: ast::FnDef = {
  <loc_1: @L> <ty: Type> <loc_2: @R> <loc_3: @L> <ident: PIdent> <loc_4: @R> "(" <args: List<Arg, Comma>> ")" <block: Block> =>ast::FnDef {
      ty,
      ty_loc: Location { begin: loc_1, end: loc_2 },
      ident,
      ident_loc: Location { begin: loc_3, end: loc_4 },
      args,
      block,
  }, // FnDef
};

pub Arg: ast::Arg = {
  <loc_1: @L> <ty: Type> <loc_2: @R> <loc_3: @L> <ident: PIdent> <loc_4: @R> => ast::Arg {
      ty,
      ty_loc: Location { begin: loc_1, end: loc_2 },
      ident,
      ident_loc: Location { begin: loc_3, end: loc_4 },
  }, // Arg
};

pub Block: ast::Block = {
    "{" <stmts: ListNoSep<Stmt>> "}" => ast::Block { <> }, // Block
};

// ------------------- STATEMENTS -------------------
// Grammar got modified to avoid conflicts using method des\]cribed here:
// https://en.wikipedia.org/wiki/Dangling_else#Avoiding_the_conflict_in_LR_parsers

pub Stmt: ast::Stmt = {
    OpenStmt,
    ClosedStmt,
};

pub OpenStmt: ast::Stmt = {
  "if" "(" <expr: Expr> ")" <stmt: SimpleStmt> => ast::Stmt::Cond {
      expr,
      stmt: Box::new(stmt),
  }, // Cond

  "if" "(" <expr: Expr> ")" <stmt: OpenStmt> => ast::Stmt::Cond {
      expr,
      stmt: Box::new(stmt),
  }, // Cond

  "if" "(" <expr: Expr> ")" <stmt_true: ClosedStmt> "else" <stmt_false: OpenStmt> => ast::Stmt::CondElse {
      expr,
      stmt_true: Box::new(stmt_true),
      stmt_false: Box::new(stmt_false),
  }, // CondElse

  "while" "(" <expr: Expr> ")" <stmt: OpenStmt> => ast::Stmt::While {
      expr,
      stmt: Box::new(stmt),
  }, // While
};

pub ClosedStmt: ast::Stmt = {
  SimpleStmt,

  "if" "(" <expr: Expr> ")" <stmt_true: ClosedStmt> "else" <stmt_false: ClosedStmt> => ast::Stmt::CondElse {
      expr,
      stmt_true: Box::new(stmt_true),
      stmt_false: Box::new(stmt_false),
  }, // CondElse

  "while" "(" <expr: Expr> ")" <stmt: ClosedStmt> => ast::Stmt::While {
      expr,
      stmt: Box::new(stmt),
  }, // While
};

pub SimpleStmt: ast::Stmt = {
  ";" => ast::Stmt::Empty, // Empty

  <block: Block> => ast::Stmt::BStmt { <> }, // BStmt

  <loc_1: @L> <ty: Type> <loc_2: @R> <items: List<Item, Comma>> ";" => ast::Stmt::Decl { // Decl
      ty,
      ty_loc: Location { begin: loc_1, end: loc_2 },
      items,
  },

  <loc_1: @L> <ident: PIdent> <loc_2: @R> "=" <expr: Expr> <loc_3: @R> ";" => ast::Stmt::Ass { // Ass
      ident,
      ident_loc: Location { begin: loc_1, end: loc_2 },
      expr,
      all_loc: Location { begin: loc_1, end: loc_3 },
  },

  <loc_1: @L> <ident: PIdent> <loc_2: @R> "++" <loc_3: @R> ";" => ast::Stmt::Incr { // Incr
      ident,
      ident_loc: Location { begin: loc_1, end: loc_2 },
      all_loc: Location { begin: loc_1, end: loc_3 },
  },

  <loc_1: @L> <ident: PIdent> <loc_2: @R> "--" <loc_3: @R> ";" => ast::Stmt::Decr { // Decr
      ident,
      ident_loc: Location { begin: loc_1, end: loc_2 },
      all_loc: Location { begin: loc_1, end: loc_3 },
  },

  <loc_1: @L> "return" <expr: Expr> <loc_2: @R> ";" => ast::Stmt::Ret { // Ret
      expr,
      all_loc: Location { begin: loc_1, end: loc_2 },
  },

  <loc_1: @L> "return" <loc_2: @R> ";" => ast::Stmt::VRet { // VRet
      all_loc: Location { begin: loc_1, end: loc_2 },
  },

  <expr: Expr> ";" => ast::Stmt::SExp { <> }, // SExp
};

pub Item: ast::Item = {
    <loc_1: @L> <ident: PIdent> <loc_2: @R> => ast::Item::NoInit {
        ident,
        ident_loc: Location { begin: loc_1, end: loc_2 },
    }, // NoInit

    <loc_1: @L> <ident: PIdent> <loc_2: @R> "=" <loc_3: @L> <expr: Expr> <loc_4: @R> => ast::Item::Init {
        ident,
        ident_loc: Location { begin: loc_1, end: loc_2 },
        expr,
        expr_loc: Location { begin: loc_3, end: loc_4 },
    },   // Init
};

// ------------------- EXPRESSIONS -------------------

pub Expr: ast::Expr = {
    <expr1 :Expr1> "||" <expr2: Expr> => ast::Expr::EOr { // EOr
        expr1: Box::new(expr1),
        expr2: Box::new(expr2),
    },
    Expr1,
};

pub Expr1: ast::Expr = {
    <expr1: Expr2> "&&" <expr2: Expr1> => ast::Expr::EAnd {
        expr1: Box::new(expr1),
        expr2: Box::new(expr2),
    }, // EAnd
    Expr2,
};

pub Expr2: ast::Expr = {
    <expr1: Expr2> <op: RelOp> <expr2: Expr3> => ast::Expr::ERel {
        op,
        expr1: Box::new(expr1),
        expr2: Box::new(expr2),
    }, // ERel
    Expr3,
};

pub Expr3: ast::Expr = {
    <expr1: Expr3> <op: AddOp> <expr2: Expr4> => ast::Expr::EAdd {
        op,
        expr1: Box::new(expr1),
        expr2: Box::new(expr2),
    }, // EAdd
    Expr4,
};

pub Expr4: ast::Expr = {
    <expr1: Expr4> <op: MulOp> <expr2: Expr5> => ast::Expr::EMul {
        op,
        expr1: Box::new(expr1),
        expr2: Box::new(expr2),
    }, // EMul
    Expr5,
};

pub Expr5: ast::Expr = {
    "-" <expr: Expr6> => ast::Expr::ENeg {
        expr: Box::new(expr),
    }, // Neg
    "!" <expr: Expr6> => ast::Expr::ENot {
        expr: Box::new(expr),
    }, // Not
    Expr6,
};

pub Expr6: ast::Expr = {
    <loc_1: @L> <ident: PIdent> <loc_2: @R> => ast::Expr::EVar {
        ident,
        ident_loc: Location { begin: loc_1, end: loc_2 },
    }, // EVar
    <value: PInteger> => ast::Expr::ELitInt { <> },   // ELitInt
    "true" => ast::Expr::ELitTrue {},  // ELitTrue
    "false" => ast::Expr::ELitFalse {}, // ELitFalse
    <loc_1: @L> <ident: PIdent> <loc_2: @R> "(" <loc_3: @L> <args: List<Expr, Comma>> <loc_4: @R>  ")" => ast::Expr::EApp {
        ident,
        ident_loc: Location { begin: loc_1, end: loc_2 },
        args,
        args_loc: Location { begin: loc_3, end: loc_4 },
    },      // EApp
    <value: PString>  => ast::Expr::EString { <> },   // EString
    "(" <expr: Expr> ")" => expr,
};

// ------------------- Operators -------------------

pub AddOp: ast::AddOp = {
    "+" => ast::AddOp::Plus,  // Plus
    "-" => ast::AddOp::Minus, // Minus
};

pub MulOp: ast::MulOp = {
    "*" => ast::MulOp::Times, // Times
    "/" => ast::MulOp::Div,   // Div
    "%" => ast::MulOp::Mod,   // Mod
};

pub RelOp: ast::RelOp = {
    "<"  => ast::RelOp::LTH, // LTH
    "<=" => ast::RelOp::LE,  // LE
    ">"  => ast::RelOp::GTH, // GTH
    ">=" => ast::RelOp::GE,  // GE
    "==" => ast::RelOp::EQU, // EQU
    "!=" => ast::RelOp::NE,  // NE
};

// ------------------- BASIC PARSING TYPES -------------------

pub PInteger: i32 = {
  r"\d+" => i32::from_str(<>).unwrap(),
};

pub PIdent: String = {
  r"[a-zA-Z][[:word:]]*" => String::from(<>),
};

pub PString: String = {
  r#""[[:print:]--"]*""# => String::from(<>),
};
